# Задание #5 Масштабирование вычислительных ресурсов: конкурирующие потребители (Competing Consumers), каналы обработки (Pipes)
## Постановка задачи
Функционал системы оценки текста постепенно развивается и теперь представляет собой сложный процесс с множеством этапов и специализированных алгоритмов. Также значительно выросло количество пользователей системы.

Появились следующие проблемы:

1.	Процесс оценки текста стал занимать продолжительное время и пользователей начала раздражать длительность ожидания. Нужно увеличить скорость обработки.

2.	Монолитный модуль стал причинять неудобства в процессе разработки, такие как сложность защиты разработанных алгоритмов, зависимость между командами разработчиков, неэффективное использование оборудования и пр.

## Реализация

Модифицируется компонент *TextRankCalc*. Добавляются компоненты **VowelConsCounter** и **VowelConsRater**.

1.	**TextRankCalc** – при запуске начинает слушать события *TextCreated* в шине сообщений *events*. При получении сообщения помещает сообщение с задачей **CalculateVowelConsJob(contextId)** в очередь **vowel-cons-counter-jobs**.

2.	**VowelConsCounter** – при запуске начинает слушать сообщения **CalculateVowelConsJob** в очереди **vowel-cons-counter-jobs**. При получении сообщения по *contextId* извлекает из Redis соответствующий текст, подсчитывает количество гласных и согласных букв и отправляет сообщение с задачей **RateVowelConsJob(contextId, vowelNum, consNum)** в очередь **vowel-cons-rater-jobs**.

3.	**VowelConsRater** – при запуске начинает слушать сообщения **RateVowelConsJob** в очереди **vowel-cons-rater-jobs**. При получении подсчитывает оценку текста как отношение vowelNum / consNum из сообщения и записывает в Redis полученную оценку по идентификатору contextId (как это прежде делалалось в монолитном *TextRankCalc*).

В скриптах запуска/остановки нужно реализовать возможность запускать несколько экземпляров **VowelConsCounter** и **VowelConsRater**. Количество экземпляров каждого указывается через конфигурационный файл (например *VowelConsCounter* - 3 экземпляра, *VowelConsRater* – 2 экземпляра).

## Замечания
Компоненты TextRankCalc, VowelConsCounter, VowelConsRater в данной задаче объединяются в **канал обработки (Pipe)**.

Поток обработки схематично можно отобразить так:

*event(TextCreated)* => **TextRankCalc**(1 экз) => *job(CalculateVowelConsJob)* => **VowelConsCounter**(N экз.) => *job(RateVowelConsJob)* => **VowelConsRater**(L экз.)

Параллельно запущенные экземпляры процессов представляют собой **конкурирующих потребителей**.

В репозитории можно посмотреть пример реализации шаблона **Producer-Consumer** с помощью библиотеки StackExchange.Redis

## Ссылки:

https://docs.microsoft.com/en-us/azure/architecture/patterns/pipes-and-filters

https://docs.microsoft.com/en-us/azure/architecture/patterns/competing-consumers

